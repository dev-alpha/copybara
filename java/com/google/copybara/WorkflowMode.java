// Copyright 2016 Google Inc. All Rights Reserved.
package com.google.copybara;

import static com.google.copybara.WorkflowOptions.CHANGE_REQUEST_PARENT_FLAG;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;
import com.google.copybara.Destination.WriterResult;
import com.google.copybara.Origin.ChangesVisitor;
import com.google.copybara.Origin.VisitResult;
import com.google.copybara.doc.annotations.DocField;
import com.google.copybara.util.console.ProgressPrefixConsole;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Workflow type to run between origin an destination
 */
public enum WorkflowMode {
  /**
   * Create a single commit in the destination with new tree state.
   */
  @DocField(description = "Create a single commit in the destination with new tree state.")
  SQUASH {
    @Override
    <R extends Origin.Reference> void run(Workflow<R>.RunHelper runHelper)
        throws RepoException, IOException, ValidationException {
      MsgTransformerCtx<R> ctx = msgTransformerForSquash(runHelper,
          runHelper.getAuthoring().getDefaultAuthor());
      runHelper.migrate(
          runHelper.getResolvedRef(),
          // SQUASH workflows always use the default author
          ctx.getAuthor(),
          runHelper.getConsole(),
          ctx.getMessage());
    }

    /**
     * Creates a commit message to correspond to an import of any number of changes in the origin.
     * TODO(malcon): Refactor this to a SkylarkFunction and remove method
     */
    private <R extends Origin.Reference> MsgTransformerCtx<R> msgTransformerForSquash(
        Workflow<R>.RunHelper runHelper, Author defaultAuthor)
        throws RepoException, ValidationException {
      StringBuilder defaultMsg = new StringBuilder(
          String.format("Imports '%s'.\n\n", runHelper.configName()));
      defaultMsg.append("This change was generated by Copybara (go/copybara).\n");
      ImmutableList<Change<R>> changes = ImmutableList.of();
      try {
        // Reverse since changesSinceLastImport returns the first commit to import
        // first.
        changes = runHelper.changesSinceLastImport();
      } catch (RepoException e) {
        if (runHelper.includeChangeListNotes()) {
          logger.log(Level.WARNING, "Previous reference couldn't be resolved");
        }
      }
      if (runHelper.includeChangeListNotes()) {
        defaultMsg.append('\n').append(changes.isEmpty()
            ? "(List of included changes could not be computed)\n"
            : "List of included changes:\n");
        for (Change<R> change : changes) {
          defaultMsg.append(String.format("  - %s %s by %s\n",
              change.getReference().asString(), change.firstLineMessage(),
              change.getAuthor()));
        }
      }
      return runHelper.transformMetadata(defaultMsg.toString(), defaultAuthor, changes.reverse(),
          ImmutableList.<Change<R>>of());
    }
  },

  /**
   * Import each origin change individually.
   */
  @DocField(description = "Import each origin change individually.")
  ITERATIVE {
    @Override
    <R extends Origin.Reference> void run(Workflow<R>.RunHelper runHelper)
        throws RepoException, IOException, ValidationException {
      ImmutableList<Change<R>> changes = runHelper.changesSinceLastImport();
      int changeNumber = 1;
      UnmodifiableIterator<Change<R>> changesIterator = changes.iterator();
      Deque<Change<R>> migrated = new ArrayDeque<>();
      while (changesIterator.hasNext()) {
        Change<R> change = changesIterator.next();
        String prefix = String.format(
            "Change %d of %d (%s): ",
            changeNumber, changes.size(), change.getReference().asString());
        WriterResult result;
        try {
          Author author = change.getAuthor();
          MsgTransformerCtx<R> ctx = runHelper.transformMetadata(
              change.getMessage(), author, ImmutableList.of(change), migrated);
          runHelper.transformMetadata(change.getMessage(), author, ImmutableList.of(change),
              migrated);
          result = runHelper.migrate(
              change.getReference(),
              ctx.getAuthor(),
              new ProgressPrefixConsole(prefix, runHelper.getConsole()),
              ctx.getMessage());
        } catch (EmptyChangeException e) {
          runHelper.getConsole().warn(e.getMessage());
          result = WriterResult.OK;
        }
        migrated.addFirst(change);

        if (result == WriterResult.PROMPT_TO_CONTINUE && changesIterator.hasNext()) {
          // Use the regular console to log prompt and final message, it will be easier to spot
          if (!runHelper.getConsole()
              .promptConfirmation("Continue importing next change?")) {
            String message = String.format("Iterative workflow aborted by user after: %s", prefix);
            runHelper.getConsole().warn(message);
            throw new ChangeRejectedException(message);
          }
        }
        changeNumber++;
      }
    }
  },
  @DocField(description = "Import an origin tree state diffed by a common parent"
      + " in destination. This could be a GH Pull Request, a Gerrit Change, etc.")
  CHANGE_REQUEST {
    @Override
    <R extends Origin.Reference> void run(Workflow<R>.RunHelper runHelper)
        throws RepoException, IOException, ValidationException {
      final AtomicReference<String> requestParent = new AtomicReference<>(
          runHelper.workflowOptions().changeBaseline);
      final String originLabelName = runHelper.getDestination().getLabelNameWhenOrigin();
      if (Strings.isNullOrEmpty(requestParent.get())) {
        runHelper.getOrigin().visitChanges(runHelper.getResolvedRef(), new ChangesVisitor() {
          @Override
          public VisitResult visit(Change<?> change) {
            if (change.getLabels().containsKey(originLabelName)) {
              requestParent.set(change.getLabels().get(originLabelName));
              return VisitResult.TERMINATE;
            }
            return VisitResult.CONTINUE;
          }
        }, runHelper.getAuthoring());
      }

      if (Strings.isNullOrEmpty(requestParent.get())) {
        throw new ValidationException(
            "Cannot find matching parent commit in in the destination. Use '"
                + CHANGE_REQUEST_PARENT_FLAG
                + "' flag to force a parent commit to use as baseline in the destination.");
      }
      Change<R> change = runHelper.getOrigin().change(
          runHelper.getResolvedRef(), runHelper.getAuthoring());
      MsgTransformerCtx<R> ctx = runHelper.transformMetadata(change.getMessage(),
          change.getAuthor(),
          ImmutableList.of(change), ImmutableList.<Change<R>>of());
      runHelper.migrate(
          runHelper.getResolvedRef(),
          ctx.getAuthor(),
          runHelper.getConsole(),
          ctx.getMessage(),
          requestParent.get());
    }
  },

  // TODO(copybara): Implement
  @DocField(description = "Mirror individual changes from origin to destination. Requires that "
      + "origin and destination are of the same type and that they support mirroring.",
      undocumented = true)
  MIRROR {
    @Override
    <R extends Origin.Reference> void run(Workflow<R>.RunHelper helper)
        throws RepoException, IOException, ValidationException {
      throw new UnsupportedOperationException("WorkflowMode 'MIRROR' not implemented.");
    }
  };

  private static final Logger logger = Logger.getLogger(WorkflowMode.class.getName());

  abstract <R extends Origin.Reference> void run(Workflow<R>.RunHelper runHelper)
      throws RepoException, IOException, ValidationException;
}
