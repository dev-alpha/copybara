package com.google.copybara;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.copybara.Origin.Reference;
import com.google.copybara.Origin.ReferenceFiles;
import com.google.copybara.transform.Transformation;
import com.google.copybara.transform.ValidationException;
import com.google.copybara.util.PathMatcherBuilder;
import com.google.copybara.util.console.Console;

import java.io.IOException;
import java.nio.file.Path;
import java.util.logging.Level;

/**
 * Migrates all pending changes as one change.
 */
public class SquashWorkflow<O extends Origin<O>> extends Workflow<O> {

  private final boolean includeChangeListNotes;

  SquashWorkflow(String configName, String workflowName, Origin<O> origin, Destination destination,
      Transformation transformation, Console console, String lastRevisionFlag,
      boolean includeChangeListNotes, PathMatcherBuilder excludedOriginPaths) {
    super(configName, workflowName, origin, destination, transformation, lastRevisionFlag,
        console, excludedOriginPaths);
    this.includeChangeListNotes = includeChangeListNotes;
  }

  @Override
  public void runForRef(Path workdir, ReferenceFiles<O> resolvedRef)
      throws RepoException, IOException, EnvironmentException, ValidationException {
    resolvedRef.checkout(workdir);
    removeExcludedFiles(workdir);

    transform(workdir, console);

    getDestination()
        .process(new TransformResult(workdir, resolvedRef, getCommitMessage(resolvedRef)), console);
  }

  private String getCommitMessage(ReferenceFiles<O> resolvedRef) throws RepoException {
    return String.format(
        "Imports '%s'.\n\n"
            + "This change was generated by Copybara (go/copybara).\n%s\n", getConfigName(),
        getChangeListNotes(resolvedRef));
  }

  private String getChangeListNotes(Reference<O> resolvedRef) throws RepoException {
    if (!includeChangeListNotes) {
      return "";
    }
    String previousRef = getPreviousRef();
    if (Strings.isNullOrEmpty(previousRef)) {
      return "";
    }
    ImmutableList<Change<O>> changes;
    try {
      changes = getOrigin().changes(getOrigin().resolve(previousRef), resolvedRef);
    } catch (RepoException e) {
      logger.log(Level.WARNING, "Previous reference couldn't be resolved", e);
      return "(List of included changes could not be computed)\n";
    }
    StringBuilder result = new StringBuilder("List of included changes:\n");
    for (Change<O> change : changes) {
      result.append(String.format("  - %s %s by %s\n",
          change.getReference().asString(),
          change.firstLineMessage(),
          change.getAuthor()));
    }

    return result.toString();
  }

  private String getPreviousRef() throws RepoException {
    if (!Strings.isNullOrEmpty(lastRevisionFlag)) {
      return lastRevisionFlag;
    }
    return getDestination().getPreviousRef(getOrigin().getLabelName());
  }
}
